package spamizer.entity;

import javafx.scene.control.Tab;
import javafx.util.Pair;

import javax.swing.plaf.nimbus.State;
import java.sql.*;
import java.util.*;

public class Database {


    public enum Table {
        SPAM("SPAM"),
        HAM("HAM"),
        MESSAGE("MESSAGE")
        ;


        private final String table;

        /**
         * @param table
         */
        Table(final String table) {
            this.table = table;
        }

        /* (non-Javadoc)
         * @see java.lang.Enum#toString()
         */
        @Override
        public String toString() {
            return table;
        }
    }

    public enum Column {
        SPAM("SPAM"),
        HAM("HAM"),

        ;


        private final String column;

        /**
         * @param table
         */
        Column(final String table) {
            this.column = table;
        }

        /* (non-Javadoc)
         * @see java.lang.Enum#toString()
         */
        @Override
        public String toString() {
            return column;
        }
    }

    private static Database database;
    private static Connection connection;



    private Database(){}

    private static void init() throws ClassNotFoundException, SQLException {
        database = new Database();
        Class.forName("org.hsqldb.jdbc.JDBCDriver");
        database.connection = DriverManager.getConnection("jdbc:hsqldb:mem:spamizer_db","spamizer", ""); //"SA", "");

        /**
         * Configurem la base de dades per que s'utilitzi la sintaxis mysql.
         */
        Statement statement = connection.createStatement();
        statement.execute("SET DATABASE SQL SYNTAX MYS TRUE");
        statement.close();

        /** Es creen dues taules degut a que sinó es repeteix la clau primària
         *  Si s'utilitza le booleà queda tot bifurcat, el codi quedarà més senzill si passem el nom de la taula per paràmetre.
         */
        database.createTable(Table.HAM);
        database.createTable(Table.SPAM);
        database.createTable(Table.MESSAGE,"(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 10) PRIMARY KEY, ham integer, spam integer)");
        //inserir els primers contadors
        database.insertFirstCounters();

    }

    public static Database getInstance() throws SQLException, ClassNotFoundException {
        if(database == null) {
            database.init();
        }
        return database;
    }

    private void createTable(Table tableName) throws SQLException {
       /* Statement statement = connection.createStatement();
        statement.executeUpdate("CREATE TABLE " + tableName + "(word VARCHAR(255) not NULL, times INTEGER, PRIMARY KEY (word))");
        statement.close();
        */
       createTable(tableName, "(word VARCHAR(255) not NULL, times INTEGER, PRIMARY KEY (word))");
    }

    private void createTable(Table tableName, String columnQuery) throws SQLException{
        Statement statement = connection.createStatement();
        statement.executeUpdate("CREATE TABLE " + tableName + columnQuery);
        statement.close();
    }

    private void insertOrUpdate(Statement statement, Table table, String word, int times) throws SQLException {

        // En la següent query es fa un insert or update
/*        String insert = "MERGE INTO " + table + " AS t USING (" +
                            "VALUES('"+ word + "'," + times + ")" +
                        ") AS vals(word, times) ON t.WORD=VALS.word " +
                        "WHEN MATCHED THEN UPDATE SET t.times=t.times+vals.times " +
                        "WHEN NOT MATCHED THEN INSERT VALUES vals.word, vals.times";*/

        String insert = "INSERT INTO " + table + "(word, times) " +
                "VALUES ('" + word + "'," + times + ") as times" +
                "ON DUPLICATE KEY UPDATE times = times + " + times;

        statement.executeUpdate(insert);

    }

    public void insertOrUpdate(Table table, HashMap<String, Integer> appearances) throws SQLException {
        Statement statement = connection.createStatement();
        Table complementaryTable = Table.HAM;
        if (table == Table.HAM)
            complementaryTable = Table.SPAM;

        if(appearances.size() > 0) {
            String insert = "MERGE INTO " + table + " using (values";
            String coInsert = "MERGE INTO " + complementaryTable + " using (values";
            for (Map.Entry<String, Integer> element : appearances.entrySet()) {
                insert += "('" + element.getKey() + "'," + element.getValue() + "),";
                coInsert += "('" + element.getKey() + "'," + 0 + "),";
            }


            insert = insert.substring(0, insert.length() - 1);
            coInsert = coInsert.substring(0, coInsert.length() - 1);
            insert += ") as vals(x, y) ON " + table + ".word = vals.x " +
                    "when matched then update set " + table + ".times = " + table + ".times + vals.y " +
                    "when not matched then insert values vals.x, vals.y";
            coInsert += ") as vals(x, y) ON " + complementaryTable + ".word = vals.x " +
                    "when matched then update set " + complementaryTable + ".times = " + complementaryTable + ".times + vals.y " +
                    "when not matched then insert values vals.x, vals.y";


            statement.executeUpdate(insert);
            statement.executeUpdate(coInsert);
        }
        statement.close();
    }

    private void insertFirstCounters() throws SQLException {
        Statement statement = connection.createStatement();
        String insert = "INSERT INTO " + Table.MESSAGE + "(HAM, SPAM) " +
                " VALUES(0,0)";
        statement.executeUpdate(insert);
        statement.close();
    }

    public void updateCounters(int ham, int spam) throws SQLException {
        Statement statement = connection.createStatement();
        String update ="UPDATE " + Table.MESSAGE +
                " SET HAM = HAM +" + ham + ","+
                "    SPAM = SPAM +" + spam +
                " WHERE ID = 1";
        statement.executeUpdate(update);
        statement.close();
    }

    public String select(Table table) throws SQLException {
        Statement statement = connection.createStatement();
        ResultSet res = statement.executeQuery("SELECT * FROM " + table);
        String result = "";
        while(res.next()) {
            result += res.getString("word") + " " + res.getInt("times") + "\n";
        }
        statement.close();
        return result;
    }

    public String selectCounters() throws SQLException {
        Statement statement = connection.createStatement();
        ResultSet res = statement.executeQuery("SELECT * FROM " + Table.MESSAGE);
        String result = "";
        while(res.next()) {
            result += res.getInt("HAM") + " " + res.getInt("SPAM") + "\n";
        }
        statement.close();
        return result;
    }


    public double getMessageProbabylity(Column column) throws SQLException {
        Statement statement = connection.createStatement();
        String query = "Select CAST(" + column + " as FLOAT)/CAST((HAM + SPAM) as FLOAT) as PTOTAL from " +Table.MESSAGE + " where id = 1 ";

        ResultSet rs = statement.executeQuery(query);
        float    result=0;

        while(rs.next()){
            result += rs.getDouble("PTOTAL");
        }

        statement.close();
        return result;
    }

    public int getCountAlphabet(Table table) throws SQLException {
        Statement statement = connection.createStatement();
        int result=0;
        String query = "SELECT count(*) +  (select sum(times) from "+ table +" ) as totalword " +
                "from ( SELECT word FROM spam  UNION SELECT word FROM ham) as t";

        ResultSet rs= statement.executeQuery(query);
        if(rs.next())
            result = rs.getInt("totalword");

        statement.close();
        return result;
    }

    public double calculateProbability(List<String> words, Table table, int k, int totalWords) throws SQLException {
        Statement statement = connection.createStatement();
        String query = "SELECT exp(sum(ln(CAST(times + " + k +" as FLOAT)/Cast( "+totalWords+" as FLOAT)))) FROM "  +table;
        if(!words.isEmpty())
            query += " WHERE word IN (";
        for(String word:words){
            query+= "'"+ word + "',";
        }
        if(!words.isEmpty()) {
            query = query.substring(0,query.length()-1);
            query += ")";
        }
        ResultSet res= statement.executeQuery(query);
        double result = 0;
        while(res.next()) {
            result = res.getDouble(1);
           //result += res.getString("word") + " " + res.getInt("times") + "\n";
        }
        statement.close();
        return result;

    }

    public int count(Table table) throws SQLException{
        Statement statement = connection.createStatement();
        ResultSet res = statement.executeQuery("SELECT COUNT(*) AS COUNT FROM " + table);
        return returnInteger(res, "COUNT");
    }

    public int sum(Table table) throws SQLException{
        Statement statement = connection.createStatement();
        ResultSet res = statement.executeQuery("SELECT SUM(times) AS addition FROM " + table);
        return  returnInteger(res, "addition");
    }

    private int returnInteger(ResultSet res, String label){
        try{
            if(res.next())
                return res.getInt(label);
            else
                return -1;
        }
        catch (Exception e){
            return -1;
        }
    }
}

