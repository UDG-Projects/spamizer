---
title: "spamizer"
author: "Marc Sànchez, Francesc Xavier Bullich, Gil Gassó"
date: "5/8/2019"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

\newpage

// TODO : Posar el projecte al github.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Carreguem les llibreries
library(scatterplot3d)
library(ggplot2)
library(colorspace)
library("plot3D")

# Carreguem les dades per a l'execució del gràfic.
#resultsP1723K005 = read.csv("/home/marc/projects/spamizer/analisys/2000m-1000n-phi-1.7-2.3-k-0-0.5.csv")
```


```{r Functions}

# x és el nom del fitxer que volem carregar
loadFormattedData <- function(x){
  
  tmp = read.csv(x)
  names(tmp) <- c("id", "phi", "k", "tp", "tn", "fp", "fn", "nham", "nspam")
  
  #Calculem els tcr dels valors 
  # BASE :  (NSPAM) / (50 * NHAM + NSPAM) 
  base <- tmp$nspam / (50 * tmp$nham + tmp$nspam)
  # WERR: (50 * FP + FN)/(50 * NHAM + NSPAM) + 0.000001 -> per que no sigui 0
  werr <- (50 * tmp$fp + tmp$fn) / (50 * tmp$nham + tmp$nspam) + 0.000001
  # TCR : BASE / WERR
  tcr <- base/werr
  
  # Calculem l'accuracy
  accuracy <- (tmp$nspam + tmp$nham - tmp$fp - tmp$fn)/(tmp$nspam + tmp$nham) * 100
  
  # Generar una matriu que permeti representar els resultats en funció de k i phi
  values <- data.frame(accuracy, tcr)
  names(values) <- c("accuracy", "tcr")
  head(values)
  
  tmp <- cbind(tmp, values)
  
  # Ordenem els valors
  tmp <- tmp[order(-tmp$tcr), ]

   return(tmp)
}

```





# Naive Bayes

En aquest apartat s'especifica com s'adapta el mètode de naive bayes al filtratge de correu. 

## Naive Bayes. 

// TODO : S'ha de parlar de tot el que es fa a dins del mètode que tenim implementat al codi. 

## Assumpcions.

// TODO : Comentar tot el que es dona per sentat al utilitzar aquest mètode, com per exemple que la màquina està ben entrenada ... 

## Punts forts i febles del mètode de Naive Bayes.

// TODO : 

# Applicació.

En aquest apartat s'es

## Tecnologies escollides.

Comentar també la comparació de l'ús de base de dades en memòria. 

## Manual de l'aplicació.

```{r app_manual}
# usage: spamizer
#  -c <arg>   Usage : -c <spamDir> <hamDir> [-n <int>]
#             Receives 2 parameters, A directory with spam mails and a
#             directory with ham mails. A calculation for values phi and k
#             will be done using a selection for the mails set. By default
#             the selection will be random based on k-fold cross-validation
#             and the heuristic method used to calculate phi and k values
#             will be random
#  -d         Flag that indicates that data must be loaded from local
#             database, this database is allocated inside project dir named
#             db made by csv files
#  -h         Set training mails as ham, adding this argument -s must not be
#             present
#  -n <arg>   The number of iterations for -c mode execution.
#  -p         Set the persistance of the memory database to a local database
#  -s         Set training mails as spam, adding this argument -h must not
#             be present
#  -t <arg>   Directories where training mails in txt are stored, this or
#             database argument must be present you can set a maximum of 2
#             directories in this several order : -t <spamDir> <hamDir>. If
#             only one dir is set the parameter -h or -s must be included
#  -v <arg>   Directory where validation mails in txt are stored. This
#             procedure will validate mail inside validationDir with
#             database loaded by default or stored inside memory. [-h | -s]
#             -v <validationDir> .
            
```

## Utilització.

# Implementació. 

## Lectura de fitxers. 

## Mètode de selecció.

### Adaptació del mètode K-fold cross-validation.

En comptes de realitzar la divisió ... 

## Filtre i abstracció del filtratge.

### Stanford Core NLP.

### Custom Filter.

## Entrenament. 

## Validació.

// TODO : Explicar la nostre adaptació del mètode hill climbing utilitzat. 

## Compute (Application, adaptació del mètode Hill Climbing).























# Fase Experimental.

// TODO : ... Pensar l'estructura encara. 

## Evaluació dels FP i dels FN en funció de K i PHI

// TODO : 

## Càlcul del TCR (Total Cost Ratio)

Amb el Total cost ratio podem extreure un valor que pondera amb més força el valor de les aparicions dels falços positius. El que es busca amb el Tcr és el valor màxim possibles. Per fer-ho hem realitzat vàries execucions i hem preparat una série de conclusions per intentar esbrinar les funcions phi i k que millor s'acosten al nostre problema mitjançant el càlcul del tcr. 

### Veiem com es pot generar la columna TCR

```{r tcr}
results = read.csv("/Users/marcsanchez/Projects/spamizer/analisys/20000m-500n-SF.csv")
#Calculem els tcr dels valors 
# BASE :  (NSPAM) / (50 * NHAM + NSPAM) 
base <- results$NSPAM / (50 * results$NHAM + results$NSPAM)
# WERR: (50 * FP + FN)/(50 * NHAM + NSPAM) + 0.000001 -> per que no sigui 0
werr <- (50 * results$FP + results$FN) / (50 * results$NHAM + results$NSPAM) + 0.000001
# TCR : BASE / WERR
tcr <- base/werr

# Generar una matriu que permeti representar els resultats en funció de k i phi
values <- data.frame(results$PHI, results$K, tcr)
names(values) <- c("phi", "k", "tcr")
head(values)

# Ordenem els valors
values <- values[order(-values$tcr), ]
head(values,20)

```

## Anàlisi de la PHI i la K.

Carreguem les diferents simulacions en un dataframe per poder processar les dades, utilitzem la funció loadFormattedData declarada a l'aratat de funcions del document. Aquesta funció ens afegeix les columnes calculades per l'accuracy i el tcr.  

```{r Loading data}
b1 = loadFormattedData("/Users/marcsanchez/Projects/spamizer/analisys/m20000-n9500-SF-P-16-k-03.csv")
b2 = loadFormattedData("/Users/marcsanchez/Projects/spamizer/analisys/m20000-n10000-P-15-K-03.csv")
b3 = loadFormattedData("/Users/marcsanchez/Projects/spamizer/analisys/20000m-500n-SF.csv")
b4 = loadFormattedData("/Users/marcsanchez/Projects/spamizer/analisys/2000m-1000n-phi-1.7-2.3-k-0-0.5.csv")

v <- rbind(b1, b2, b3, b4)
v <- v[order(-v$tcr), ]
head(v)
```

### PHI

Si tenim en compte el què representa el valors de phi, el que ens trobem és que la phi és el factor d'increment de la probabiltat per que un correu sigui considerat SPAM. És a dir un valor de phi = 2, provoca que per que un correu sigui considerat spam la seva probabilitat ha de ser 2 cops superior a la probabiltiat de que sigui ham. Un valor de phi = 1 fa que no hi hagi increment obligatori per a la comparació. 

El valor mínim que té sentit assignar-li a phi és 1 i el màxim el podríem limitar a 5 com a molt o inclús a 6 si el que volem és no tenir cap correu que sigui Ham i que el consideri com Spam. Aquest paràmetre se'l pot considerar més influent que el valor de k ja que el valor de phi està directament lligat al nombre de falsos positius i de falsos negatius. En canvi el valor de k representa un coeficient molt baix a aplicar a totes les paraules. 

Veiem els següents diagrames de dispersió donada una mostra de 500 punts sobre el total de les execucions.

```{r phi dispersion diagram}
m <- v[sample(nrow(v), size = 500), ]

par(mfrow=c(2,2))
plot(m$phi, m$tcr, main="PHI vs Total Cost Ratio", 
   xlab="phi", ylab="Total Cost Ratio", pch=19)

plot(m$phi, m$accuracy, main="PHI VS Accuracy", 
   xlab="phi", ylab="Accuracy", pch=19)

plot(m$phi, m$fp, main="PHI VS False positives", 
   xlab="phi", ylab="False Positives", pch=19)

plot(m$phi, m$fn, main="PHI VS False negatives", 
   xlab="phi", ylab="False negatives", pch=19)
par(mfrow=c(1,1))

```

En l'anterior grid podem veure diferents comparacions del comportament de la variable phi sobre una mostra de 500 elements dins del conjunt total de les execucions. Dels gràfics anteriors podem extreure certes conclusions a vista tenint en compte que durant les execucions no s'ha fixat en cap moment ni un ordre de lectura de correus, ni un valor per k ni un valor per phi i els correus per validar eren seleccionats aleatòriament. De totes maneres disposem d'un número molt elevat i amb molta varietat de resultats. 

- Es pot veure que la mitjana del tcr queda entre 1 i 6. 
- Es pot veure com a més valor de phi, més disminueix el nombre de fp (lentament). 
- Es pot veure com a més valor de phi més augmenta el nombre de fn (més pronunciat).
- Es pot veure com l'accuracy es entre el 97 i 99 peró que si el valor de phi augmenta llavors l'accuracy baixa 4 punts.

### K 

Quan apliquem el suavitzat hem de tenir en compte què passa si donats el bag of words de ham i el de spam una paraula no existeix. En la nostre fòrmul aquest valor ens podria proporcionar multiplicacions per 0 i farà que si una paraula no existeix aquesta paraula ja ens determini si un correu és ham o és spam. 

Per tant la k estipula el valor que se li assigna a una paraula quan aquesta no és present. Aquest valor no pot ser 0 peró pot ser proper a zero. Si fos zero es provocaria el mateix cas que l'esmentat anteriorment. Tanmateix no té sentit aplicar un valor molt gran a la k ja que si ho fem aquest valor provocaria que les paraules que no existeixen fossin puntuades molt altes i se li treuria valor de còmput a les aparicions.

```{r K dispersion diagram }

par(mfrow=c(2,2))
plot(m$k, m$tcr, main="k vs Total Cost Ratio", 
   xlab="phi", ylab="Total Cost Ratio", pch=19)

plot(m$k, m$accuracy, main="k VS Accuracy", 
   xlab="phi", ylab="Accuracy", pch=19)

plot(m$k, m$fp, main="k VS False positives", 
   xlab="phi", ylab="False Positives", pch=19)

plot(m$k, m$fn, main="k VS False negatives", 
   xlab="phi", ylab="False negatives", pch=19)

par(mfrow=c(1,1))
```

Utiitzant el mateix supòsit que en la variable phi observem doncs : 

- Amb els valors de k per el tcr passa quelcom molt similar als valors de phi.
- Amb els valors de k més petits l'accuracy ha augmenta, a mesura que es fa crèixer el valor de k més disminueix l'accuracy. 
- Veiem que no impacte molt aquest valor en el dels falços positius. 
- Per altra banda veiem que té una relació directe amb el comportament dels falços negatius. 

Limitarem els valors de k en un rang de (0 - 1]. 

### Conlusions conjuntes entre phi i k

No té sentit mirar les formes dels valors de phi i k de manera independent per què son valors generats aleatòriament, els seus histogrames es presenten de la següent manera. 

El que sí que té sentit és observar si les variables es poden descriure conjuntament amb el nombre de FP o FN i finalment si es poden comprovar mitjançant el total cost ratio. La variable phi està directament lligada amb els valors FP i FN per definició. 

```{r scatter}
par(mfrow=c(1,2))
scatter3D(v$phi, v$k, v$tcr, phi = 0, theta=0, bty = "g",  type = "h", ticktype = "detailed", pch = 19, cex = 0.5, xlab="PHI", ylab="K", zlab="TCR")
scatter3D(v$phi, v$k, v$tcr, phi = 0, theta=90, bty = "g",  type = "h", ticktype = "detailed", pch = 19, cex = 0.5, xlab="PHI", ylab="K", zlab="TCR")

par(mfrow=c(1,2))
scatter3D(v$phi, v$k, v$tcr, phi = 0, bty = "g",  type = "h", ticktype = "detailed", pch = 19, cex = 0.5)
scatter3D(v$phi, v$k, v$tcr, phi = 90, theta = 0.5, bty = "g",  type = "h", ticktype = "detailed", pch = 19, cex = 0.5)
```














Segons el coeficient de correlació lineal de Pearson la variable phi i el tcr sembla que concentrin la seva relació lineal en una línia recta i constant en un valor d'entre 1 i 5 per el tcr. Podem parlar més o menys que la variable phi li passa el mateix. 

No hem d'oblidar peró que el valor del tcr s'ha tret directament de l'execució amb les variables phi i k i per tant ens serveix per veure si hi ha algun patró pel que la funció k o la funció phi de manera independent entre elles poden fer que creixi el valor del tcr, tanmatex aixó no serà possible degut a que el valor del tcr s'extreu tant de la variable phi tant com de la variable k i **S'hauria de fixar o bé la phi o bé la k per poder extreure una conclusió sobre el tema**. 

### Cerca d'un model per la variable TCR

Podem mirar quina forma té la variable TCR segons les execucions generades. Veiem que el total cost ratio concentra per valors aleatòris el seu pes entre els valors 2 - 7.

```{r TCR histogram}
# Histograma de tcr
hist(head(tcr, 20))

# Mitjana per el valor del tcr per phi i per k amb rang entre [1,5] i (0-3].
median(tcr)
```

El que es pretén és realitzar un estudi de quan les variables phi i k considerades com a constants en l'execució del programa es comporten de manera adient per el filtratge. En una primera iteració amb prop de 1500 execucions utilitzant sense lemmatitzar amb un nombre total de 20000 correus i generant una discriminació d'entre un 5% i un 15% per a la validació ens trobem el següent gràfic. 

Veiem que amb uns valors aproximats d'entre 0 i 1 per k i entre 1.7 i 3.5 de phi, s'hi concentren els que tenen el tcr més alt. Per tant generem una altre iteració d'uns 1000 valors restringint aquest rang per phi i k en el quadrant on apareixien més aparicions dels valors de phi i de k concretament phi entre [1.7,2.3] i k entre (0,0.30] i tornant a visualitzar el resultat. 

Veiem que la mitjana ha augmentat respecte l'anterior peró poc, altres indicadors que podem fer servir son per exemple el valor màxim trobat o fins i tot la mitjana dels 50 valors més alts.

A continuació comparem els valors per les dos rangs i observerm els histogrames dels 50 valors millors per les dues distribucions de resultats per veure si ens han aparegut valors  més bons restringit el rang. 

Tenint en compte que les dades limitades son de 500 elements i les dades que tenen el rang més ampli son de 1500 i veient com es mantenen els valors més alts mirem de concretar més els resultats i si es pot ajustar més el rang dels valors generats per phi i k mitjançant els gràfics següents : 

```{r Agrouping data into a data frame}
#scatter3D(resultsP1723K005$PHI, resultsP1723K005$K, tcrl, phi = 0, bty = "g",  type = "h", ticktype = "detailed", pch = 19, cex = 0.5)
#scatter3D(resultsP1723K005$PHI, resultsP1723K005$K, tcrl, phi = 90, theta = 0.5, bty = "g",  type = "h", ticktype = "detailed", pch = 19, cex = 0.5)
```

## Recol·lecció dels millors valors 

Per ara sabem que ajustant el rang una mostra de 500 valors es comporta de manera similar que una mostra de 1500 valors ambdós generats aleatòriament tant per phi com per k, aixó ens fa pensar que aquest ajustament s'està comportant millor que el rang més ampli i que en part pot ser que haguem trobat indicis d'un màxim local de la relació de les dues variables. 

Per seguir recollirem els millors valors de les dues execucions anteriors i mirarem de centrar-los en un sol dataset per treballar-lo. Considerarem que els millors valors per nosaltres son a partir del tcr 25. 

```{r Best values}
#bestvals <- rbind(values[values$tcr > 25, ], valueslimited[valueslimited$tcr > 25, ])
#bestvals <- bestvals[order(-bestvals$tcr), ]
```

Ara presentem l'histograma de les aparicions per phi i per k, intentant cercar encara aquest màxim local que creiem que existeix en aquesta franja. 

```{r hist phi and k}
#hist(bestvals$k)
#hist(bestvals$phi)
```

Veient els resultats obtinguts i observant les aparicions i els valors de phi i k sobre el dataset bestvals s'ha decidit llençar una 3a tanda focalitzant els rangs per k i phi als valors d'entre [0.20,0.30] per k i de [1.8,2.8] per phi. 

### Focalització del valor de k. 

Carreguem els resultats.

Realitzem el mateix procediment que amb els valors anteriors. Cerquem el TCR i recollim els millors valors dins del dataframe de bestvalues. 

A partir d'aquest moment amb totes les dades més bones que tenim fins ara, és a dir amb els màxims amb els que treballem per phi i per k, si fem la mitjana de k i mirem el millor valor per tcr podem veure : 

Que la mitjana delsk millors valors per k és el mateix valor que el màxim tcr trobat. Per tant fixem el valor de k en : 0.236267. 



#### Exemple de funció K


En el següent gràfic la grandària dels punts estipula quant de gran és l'error no desitjat, és a dir, quan un correu considerat **HAM es filtra com SPAM**. Als eixos hi podem veure els valors de phi i k utiltizats per a la validació. El percentatge de correus utilitzats sobre els 200 correus totals és d'entre 5% i 15% i la selecció d'aquest valor és aleatòria. 



```{r Execucio amb 200 mail i 100 iteracions}

#head(results)

# De moment la millor opció.

#scatter3D(valores$phi, valores$k, valores$tcr, phi = 0, bty = "g",  type = "h", ticktype = "detailed", pch = 19, cex = 0.5)

#d = ggplot(valores,aes(phi, k, fill=tcr))  + ggtitle("Plot of 100 values") + xlab("PHI") + ylab("K") d + geom_point(alpha = 0.3, colour="purple", size = 3)

#firstValues <- head(valores, 30)


#ggplot(data = valores, aes(x = phi, y = k)) + geom_tile(aes(fill = tcr)) 

#grid.arrange(p1,p2,ncol=2)
#heatmap(data.matrix(valores))


#radius <- sqrt(valores$tcr/pi)
#symbols(valores$phi, valores$k, circles = radius, inches = 0.1, fg = "white", bg = "red", main = "Sized by NumVar3", alpha = 0.1)

#plot(valores$tcr~sort(valores$k), type="l")
#line(valores$tcr~sort(valores$phi), col="red")

```



## Referències  

- [R graphics](https://bl.ocks.org/patilv/raw/7360425/)
